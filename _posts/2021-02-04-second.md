---
layout: post
title: 문과생이 이해하는 선형대수 대략적인 흐름 1
subtitle: 선형대수 딥러닝 왜 ?! 
tags: [선형대수,딥러닝]
comment: True
---

## Intro - 이것을 정리하는 이유

저는 하길찬 교수님의 kocw 강의를 듣는 것을 시작으로 선형대수학을 처음 공부하였습니다. (지금 생각해도 명강의에요 👍) 그리고 이후 앤드류 응 교수님의 코세라 강의로 머신러닝 기초를 처음 공부하였습니다. 하길찬 교수님이 강의에서 암기식이 아니라 많은 내용을 최대한 깊이 있게 증명해주시면서 수학적 원리를 느껴보도록 하시는 스타일이기 때문에 처어음 대학 수학을 접해보는 저는 그러한 하나하나의 증명을 따라가는데 급급했는데 또 이후 들은 머신러닝 강의에서는 생각보다 그러한 세세한 증명까지 많이 언급되지는 않았기 때문에 개념 자체를 많이 까먹어버리거나 딥러닝에서의 필요성을 잊게 되었습니다. 그래서 온갖 개념이 난잡하게 꼬인 상태로 기초에 구멍이 많이 생기게 되었고, 그래서 지금 다시 공부를 하고 있습니다. 🤦‍♀️ 깨달음을 얻은 것이 있는데 어떠한 개념에 대한 증명을 달달 외우려고 강박을 느낄 필요는 없다는 것과 큰 흐름을 위주로 기억해야한다는 것입니다. 그래서 또 까먹게 될까봐 제 자신을 위해 한번 더 깔끔하게 정리해보면서 공부하기로 결심했습니다. 

#### 벡터의 의미

**크기 + 방향성을 가진 값** 

그러면 추상적인 벡터의 개념을 어떻게 식으로 나타낼 수 있을까 ? 

벡터가 각 축에서 갖는 방향과 값들을 종합해서 궁극적으로 벡터가 가리키는 방향이 나오기 때문에, 벡터가 각 축에서 갖는 방향과 값들을 나타내어주기 ! = 행렬과 비슷한 형식으로 쓸 수 있다.

![IMG_27A5DAFB2C4A-1](https://user-images.githubusercontent.com/67775336/106857728-dfaaaf00-6703-11eb-82cc-88b63d6e5875.jpeg)

#### 내적 

**벡터들을 연산해서(=내적해서) 어떠한 스칼라 값을 나타내고 싶은 경우 사용**

![IMG_E5AEFCB354CA-1](https://user-images.githubusercontent.com/67775336/106858248-b63e5300-6704-11eb-8ae1-f66afb71ae2f.jpeg)

**내적 연산 short cut : x벡터가 (a,b) 이고  y 벡터가 (c,d) 라고 하면 x⋅y = (axb)+(cxd)**

![스크린샷 2021-02-04 오후 4 22 39](https://user-images.githubusercontent.com/67775336/106858585-3d8bc680-6705-11eb-979a-d02764f689ff.png)

![스크린샷 2021-02-04 오후 4 22 47](https://user-images.githubusercontent.com/67775336/106858618-47152e80-6705-11eb-994c-cf82960ae2d5.png)



#### 가우스-조던 소거법 

연립방정식 해를 구할 때 수식을 행렬로 나타내어서 빠르게 구하는 것. 선형대수에서는 수식을 구할 때 항상 가우스-조던 원리를 이용하는 것 같다 (?!) 역행렬을 구할 때도 가우스-조던 소거법을 쓸 수 있다. 

![IMG_255608EC3142-1](https://user-images.githubusercontent.com/67775336/106859311-33b69300-6706-11eb-9069-8edb2743b6c7.jpeg)

해가 없거나 무한한 경우 (해를 제대로 구할 수 없는 경우) 제대로 된 기약형 사다리꼴이 나오지 않는다. ex. 가우스 조던 하면 마지막 행이 다 0 으로 나와버리는 경우 

**가우스 조던 원리** 

행렬 X는 항등행렬 (I) 에서 시작해서 서서히 변환되어나간다. 

어떠한 A 행렬에 행렬 X 를 곱해서 B행렬을 구할 때 (XA=B) A를 어떻게 B로 바꿀지의 결정권은 X의 선행성분에 달려있다. 

![스크린샷 2021-02-04 오후 4 35 57](https://user-images.githubusercontent.com/67775336/106859967-1b934380-6707-11eb-8b4e-935628c61c78.png)

![스크린샷 2021-02-04 오후 4 36 07](https://user-images.githubusercontent.com/67775336/106859990-23eb7e80-6707-11eb-925d-3dde4b5587d2.png)



#### 행렬식 

**행렬식의 정의** 

![KakaoTalk_Photo_2021-02-04-16-41-14](https://user-images.githubusercontent.com/67775336/106860575-ef2bf700-6707-11eb-8a0b-1271f7acfe03.jpeg)

![KakaoTalk_Photo_2021-02-04-16-41-22](https://user-images.githubusercontent.com/67775336/106860617-fc48e600-6707-11eb-8689-502fbff3a39a.jpeg)

![KakaoTalk_Photo_2021-02-04-16-41-29](https://user-images.githubusercontent.com/67775336/106860662-08cd3e80-6708-11eb-85a6-e75ceb8b4c55.jpeg)

![KakaoTalk_Photo_2021-02-04-16-41-36](https://user-images.githubusercontent.com/67775336/106860679-108ce300-6708-11eb-9e2c-290e3170138c.jpeg)

![KakaoTalk_Photo_2021-02-04-16-41-42](https://user-images.githubusercontent.com/67775336/106860710-1a164b00-6708-11eb-9e0a-9a6596e93ffb.jpeg)

![KakaoTalk_Photo_2021-02-04-16-41-50](https://user-images.githubusercontent.com/67775336/106860739-239fb300-6708-11eb-95b5-7546d11f59ee.jpeg)





![KakaoTalk_Photo_2021-02-04-16-41-57](https://user-images.githubusercontent.com/67775336/106860770-30bca200-6708-11eb-800d-51b5451d8e6c.jpeg)

**행렬식의 주요 성질**

I I I  = 1

만약 특정 행만 A에 K배가 되어있으면 IBI=KIAI

두 행을 맞바꾼 행렬의 행렬식은 원래 행렬식 * (-1) 이다

n*n 행렬에서 두 행이 같으면 IAI=0

A의 한 행이 0이면 IAI=0

A의 행렬식은 A의 전치행렬의 행렬식과 같다

IAI IBI = I A B I

IAI 가 0 이 아니면 A는 가역행렬이다

A가 하상각/상상각/대각행렬일 때 IAI는 행렬 A의 대각성분들의 곱이다 



#### **벡터 공간, 부분 공간**

**벡터 공간** ; 다양한 벡터들이 있고 그 벡터들이 특정 공간을 형성한 것. 따라서 "공간" 이라고 부를 수 있으려면 해당 공간 내 벡터들끼리 기본 법칙 9가지를 성립하여야한다 (덧셈의 교환법칙,덧셈의 결합법칙,덧셈의 항등원,덧셈의 역원,덧셈애 대하서 닫혀있다, 스칼라 배에 대해 닫혀있다, 스칼라 배의 결합법칙, 스칼라 배의 항등원, 분배법칙)

**부분 공간** ; 벡터 공간 내의 부분적인 공간. 즉 부분 공간을 형성하는 벡터들은 이미 특정 벡터 공간 내에 존재하는 벡터들이다. 특정 벡터 공간에서 벡터들을 어떻게 잘 끄집어왔더니 걔네끼리도 공간을 형성하는 것이다 (=걔네끼리도 9개의 법칙이 성립하는 것이다) 즉 이미 벡터 공간 내 벡터들이므로 9개 법칙을 다 증명할 필요는 없고 **덧셈과 스칼라 배에 닫혀있기만 하면 된다.** 



#### 선형 독립,선형 종속 

a 벡터가 어떻게 잘 리폼하면 (ex. 길이를 늘리고 방향을 바꾸고 ) b 벡터로 바뀐다 =>          **선형종속**

a 벡터를 어떻게 리폼해도 b 벡터는 절대 될 수 없다 => **선형독립** 

**선형독립,선형종속 판별법** 

c1a1 +c2a2 +... cnan=0 을 만족하는 상수 c1,c2,...cn 이 모두 0 이면 벡터 a1,a2,...,an 은 선형 독립.

c1a1 +c2a2 +... cnan=0 을 만족하는 상수 c1,c2,...cn 중 하나라도 0이 아닌 상수가 존재하면 벡터 a1,a2,...,an 은 선형 종속



#### 가역행렬이다 의 동의어

가역행렬이다 = 행벡터/열벡터가 선형독립이다 = 행렬식이 0이 아니다 

**증명** 

![IMG_2D006B83193E-1](https://user-images.githubusercontent.com/67775336/106862666-c6f1c780-670a-11eb-90d5-a7e060bb9f05.jpeg)



#### **기저와 차원** 

기저 : 한 벡터 공간에서 선형독립이라는 조건이 성립하는 최대한 많은 벡터를 모아놓은 것.

대표적인 기저 (1,0) (0,1) => 2차원 데카르트 좌표계를 이룸

**각 기저는 각 축을 형성한다고 볼 수 있다.** 

(1,0) => 선형결합을 통해서 x축을 형성

(0,1) => 선형결합을 통해서 y축을 형성 

총 축 두 개 (x축,y축) => 2차원 

**즉 기저 벡터 하나하나가 각 축을 형성하므로 결국 기저의 벡터 갯수는 해당 벡터 공간의 차원이 된다.** 



#### **선형변환** 

선형변환이란 어떠한 n차원 벡터공간에 속하는 행렬 X 에 행렬 A 를 곱해줌으로써 X 를 어떠한 m차원 벡터공간의 행렬 Y로 변신시키는 것이다. (AX=B)

함수로 표현해주면 f(A)=B 라고도 할 수 있다.

그냥 변환이 아니라, <u>선형</u> 변환이라고 하는 이유는 다음의 성질을 만족하기 때문이다.

(linear 하다 => 직선이 쭉쭉 뻗어있듯이 예측하기가 쉽다 => 예측하기가 쉬운 변환)

f(A+B)=f(A)+f(B) , f(c x A)=c f(A) 



![IMG_A3F58C44814C-1](https://user-images.githubusercontent.com/67775336/106866103-67e28180-670f-11eb-8dd2-3138f5535075.jpeg)

![IMG_D39BA1C89245-1](https://user-images.githubusercontent.com/67775336/106866166-7c267e80-670f-11eb-9484-defe1db9a62a.jpeg)



#### **고유값,고유벡터** 

선형변환을 시켜주었을 때 방향은 그대로이고 크기만 달라지는 벡터 = **고유벡터**

이 때 얼마나 늘어나는지 = **고유값** 

[고유값과 고유벡터의 기하학적 의미](https://www.youtube.com/watch?v=Nvc7ZRVjciM)

정말 도움을 많이 받았습니다 ㅠㅠ 공돌이님 무한감사 🙏

![IMG_51C01391F6FF-1](https://user-images.githubusercontent.com/67775336/106866836-48982400-6710-11eb-8ffb-2d1ad67432d2.jpeg)

**특성방정식** 

![IMG_1BFEB2454445-1](https://user-images.githubusercontent.com/67775336/106867350-d542e200-6710-11eb-9b55-79c1fcab081c.jpeg)

**고유벡터,고유값의 특징** 

A가 nXn 행렬일 때 고유값이 다르면 대응되는 고유벡터들은 자동으로 일차독립이 된다 



#### 선형변환과 대각화

![IMG_32CB5E59736B-1](https://user-images.githubusercontent.com/67775336/106871038-22c14e00-6715-11eb-9740-8e33ee94c466.jpeg)

**대각화 : A 를 통해 A' (고유값들을 성분으로 하는 대각행렬) 을 만들어준 것** 

**즉, n개의 일차독립인 고유벡터가 존재하면 A 를 대각화시킬 수 있다** 

PDinverse(P) =A 이므로 inverse(P)AP=D



#### 닮은 행렬

![스크린샷 2021-02-04 오후 6 29 22](https://user-images.githubusercontent.com/67775336/106873388-c1e74500-6717-11eb-9c7a-331701b8a20b.png)

[쑤튜브 선형대수 52강](https://www.youtube.com/watch?v=_e71TDZDsfE&list=PLdEdazAwz5Q_n47tqf0QY94ASCmWqeGX1&index=58)



**즉, A 행렬의 닮은 행렬이라고 해서 모두 대각행렬인 것은 아니다. 대각행렬은 A의 대각행렬이다.** 



#### 닮은 행렬과 대각화 WHY ?!

A 와 B 가 닮은 행렬이면 특정 기저를 갖는 벡터공간에 존재하는 A 를 다른 어떠한 기저를 갖는 벡터공간으로 옮기면 거기선 A 가 B로 바뀔 것이라는 의미가 된다. 

그리고 선형변환시키는 행렬이 대각행렬일 경우 대각행렬의 특징 상 어떻게 바뀌는지 규칙을 훨씬 잘 파악할 수 있다.

어떠한 벡터 공간에서의 선형변환 행렬 A 가 다른 벡터 공간에서는 대각행렬이라면 ? 

A가 대각행렬이 되는 벡터 공간을 기준으로 모든 벡터를 변환시켜준다음에 (A 포함) 선형변환을 시켜주면 (이제 A는 변환되었으니깐 D) 어떠한 인풋 값이 어떻게 변하는지 더 잘 이해할 수 있다 ! 

x => A => y (x에서 y로 무엇이 바뀐 것인지 파악하기 어려움) ; 표준 기저를 축으로 하는 벡터공간

new x => D => new y (new x 가 new y 로 무엇이 바뀐 것인지 한 눈에 규칙 파악 가능) ; 고유 벡터들을 축으로 하는 벡터 공간

![IMG_8F26DDA11467-1](https://user-images.githubusercontent.com/67775336/106874619-2060f300-6719-11eb-9a01-c0cabbc2ac24.jpeg)

## To Be Continue ... 
![스크린샷 2021-02-04 오후 8 26 51](https://user-images.githubusercontent.com/67775336/106886544-5ad18c80-6727-11eb-98c1-ec336a32df71.png)


